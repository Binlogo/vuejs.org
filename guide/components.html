<!DOCTYPE html>
<html lang="en">
    <head>
        <title>组件系统 - vue.js</title>
        <meta charset="utf-8">
        <meta name="description" content="Vue.js - Intuitive, Fast and Composable MVVM for building interactive interfaces.">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
        <!-- <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600|Lato|Inconsolata' rel='stylesheet' type='text/css'> -->
        <link rel="icon" href="/vuejs.org/images/logo.png" type="image/x-icon">
        <script>
            window.PAGE_TYPE = "guide"
        </script>
        <link rel="stylesheet" href="/vuejs.org/css/page.css" type="text/css">
        <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-46852172-1', 'vuejs.org');
  ga('send', 'pageview');
</script>
        <script src="/vuejs.org/js/vue.min.js"></script>
    </head>
    <body>
        <div id="mobile-bar">
            <a class="menu-button"></a>
            <a class="logo" href="/vuejs.org/"></a>
        </div>
        
        
            <div id="header">
    <a id="logo" href="/vuejs.org/">
        <img src="/vuejs.org/images/logo.png">
        <span>Vue.js</span>
    </a>
    <ul id="nav">
        <li><a href="/vuejs.org/guide/" class="nav-link current">入门</a></li>
<li><a href="/vuejs.org/api/" class="nav-link">API 索引</a></li>
<li><a href="/vuejs.org/examples/" class="nav-link">示例</a></li>
<li><a href="http://vuejs.org/blog/" target="_blank" class="nav-link">Blog (英文)</a></li>
<li><a href="https://github.com/yyx990803/vue" target="_blank" class="nav-link">GitHub</a></li>
<li><a href="http://vuejs.org/" target="_blank" class="nav-link">English</a></li>
    </ul>
</div>
        

        <div id="main">
            
                
    <div class="sidebar">
    <ul class="main-menu">
        <li><a href="/vuejs.org/guide/" class="nav-link current">入门</a></li>
<li><a href="/vuejs.org/api/" class="nav-link">API 索引</a></li>
<li><a href="/vuejs.org/examples/" class="nav-link">示例</a></li>
<li><a href="http://vuejs.org/blog/" target="_blank" class="nav-link">Blog (英文)</a></li>
<li><a href="https://github.com/yyx990803/vue" target="_blank" class="nav-link">GitHub</a></li>
<li><a href="http://vuejs.org/" target="_blank" class="nav-link">English</a></li>
    </ul>
    <div class="list">
        <h2>Guide</h2>
        <ul class="menu-root">
            
                <li><a href="/vuejs.org/guide/installation.html" class="sidebar-link">安装</a></li>
            
                <li><a href="/vuejs.org/guide/index.html" class="sidebar-link">起步</a></li>
            
                <li><a href="/vuejs.org/guide/directives.html" class="sidebar-link">指令</a></li>
            
                <li><a href="/vuejs.org/guide/filters.html" class="sidebar-link">过滤器</a></li>
            
                <li><a href="/vuejs.org/guide/list.html" class="sidebar-link">列表展示</a></li>
            
                <li><a href="/vuejs.org/guide/events.html" class="sidebar-link">事件监听</a></li>
            
                <li><a href="/vuejs.org/guide/forms.html" class="sidebar-link">处理表单</a></li>
            
                <li><a href="/vuejs.org/guide/computed.html" class="sidebar-link">可推导的属性</a></li>
            
                <li><a href="/vuejs.org/guide/custom-directive.html" class="sidebar-link">自定义指令</a></li>
            
                <li><a href="/vuejs.org/guide/custom-filter.html" class="sidebar-link">自定义过滤器</a></li>
            
                <li><a href="/vuejs.org/guide/components.html" class="sidebar-link current">组件系统</a></li>
            
                <li><a href="/vuejs.org/guide/transitions.html" class="sidebar-link">过渡效果</a></li>
            
                <li><a href="/vuejs.org/guide/application.html" class="sidebar-link">创建大型应用</a></li>
            
                <li><a href="/vuejs.org/guide/extending.html" class="sidebar-link">扩展 Vue</a></li>
            
                <li><a href="/vuejs.org/guide/faq.html" class="sidebar-link">常见问题</a></li>
            
            <li><a href="http://legacy.vuejs.org">旧版 0.10 文档</a></li>
            <li style="margin:10px 0 3px">
              <script data-gittip-username="yyx990803"
                data-gittip-widget="button"
                src="//gttp.co/v1.js"></script>
            </li>
        </ul>
    </div>
</div>

<div class="content guide with-sidebar">
    <h1>组件系统</h1>
    <div id="ad">
        <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=vuejs" id="_carbonads_js"></script>
    </div>
    <h2 id="使用组件">使用组件</h2>
<p>Vue.js 支持把扩展而来的 Vue 的子类用作概念上与 <a href="http://www.w3.org/TR/components-intro/" target="_blank">Web Components</a> 类似的可复用组件，无需任何 polyfill。要创建组件，只需借助 <code>Vue.extend()</code> 创建一个 Vue 的子类构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// 扩展 Vue 得到一个可复用的构造函数</span>
<span class="keyword">var</span> MyComponent = Vue.extend({
  template: <span class="string">'A custom component!'</span>
})
</pre></td></tr></table></figure>


<p>Vue 的构造函数可接收的大部分选项都能在 <code>Vue.extend()</code> 中使用，不过也有两个特例：<code>data</code> 和 <code>el</code>。由于每个 Vue 的实例都应该有自己的 <code>$data</code> 和 <code>$el</code>，我们显然不希望传递给 <code>Vue.extend()</code> 的值被所有通过这个构造函数创建的实例所共享。因此如果要定义组件初始化默认数据和元素的方式，应该传入一个函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> ComponentWithDefaultData = Vue.extend({
  data: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> {
      title: <span class="string">'Hello!'</span>
    }
  }
})
</pre></td></tr></table></figure>


<p>接下来，就可以用 <code>Vue.component()</code> 来<strong>注册</strong>这个构造函数了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">// 把构造函数注册到 my-component 这个 id</span>
Vue.component(<span class="string">'my-component'</span>, MyComponent)
</pre></td></tr></table></figure>


<p>为了更简单，也可以直接传入 option 对象来代替构造函数。如果接收到的是一个对象，<code>Vue.component()</code> 会为你隐式调用 <code>Vue.extend()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">// 注意：该方法返回全局 Vue 对象，</span>
<span class="comment">// 而非注册的构造函数</span>
Vue.component(<span class="string">'my-component'</span>, {
  template: <span class="string">'A custom component!'</span>
})
</pre></td></tr></table></figure>


<p>之后就能在父级实例的模板中使用注册过的组件了（确保在初始化根实例<strong>之前</strong>已经注册了组件）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 父级模板 --&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">v-component</span>=<span class="value">"my-component"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>


<p>如果你愿意，也能以自定义元素标签的形式使用组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">my-component</span>&gt;</span><span class="tag">&lt;/<span class="title">my-component</span>&gt;</span>
</pre></td></tr></table></figure>


<p class="tip">为了避免与本地元素发生命名冲突，也为了与 W3C 自定义元素规范一致，组件的 ID <strong>必须</strong>包含一个连字符 <code>-</code> 才能作为自定义标签使用。</p>

<p>理解 <code>Vue.extend()</code> 和 <code>Vue.component()</code> 的区别至关重要。由于 <code>Vue</code> 本身是一个构造函数， <code>Vue.extend()</code> 是一个<strong>类继承方法</strong>。它用来创建一个 <code>Vue</code> 的子类并返回其构造函数。而另一方面，<code>Vue.component()</code> 是一个类似 <code>Vue.directive()</code> 和 <code>Vue.filter()</code> 的<strong>资源注册方法</strong>。它作用是建立指定的构造函数与 ID 字符串间的关系，从而让 Vue.js 能在模板中使用它。直接向 <code>Vue.component()</code> 传递 options 时，它会在内部调用 <code>Vue.extend()</code>。</p>
<p>Vue.js 支持两种不同的 API 规范：基于类的命令式的 Backbone 风格 API，以及基于标记的声明式的 Web Components 风格 API。如果你感到困惑，想一下通过 <code>new Image()</code> 和通过 <code>&lt;img&gt;</code> 标签这两种创建图片元素的方式。它们都在各自的适用场景下发挥着作用，为了尽可能灵活，Vue.js 同时提供这两种方式。</p>
<h2 id="数据继承">数据继承</h2>
<h3 id="显式数据传递">显式数据传递</h3>
<p>默认情况下，组件有<strong>独立作用域</strong>。这意味着你无法在子组件的模板中引用父级的数据。可以通过 <code>v-with</code> 命令把数据显式传递给拥有独立作用域的子组件。</p>
<h4 id="向下传递子_$data_对象">向下传递子 <code>$data</code> 对象</h4>
<p>只给出 keypath 而不传递参数时，父级上相应的数据会传递给子级作为 <code>$data</code> 对象。这意味着传递的数据必须是一个对象，并且它会覆盖子组件可能包含的默认 <code>$data</code> 对象。</p>
<p><strong>示例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"demo-1"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span> <span class="attribute">v-component</span>=<span class="value">"user-profile"</span> <span class="attribute">v-with</span>=<span class="value">"user"</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>




<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="comment">// 先注册组件</span>
Vue.component(<span class="string">'user-profile'</span>, {
  template: <span class="string">'{&#123;name&#125;}&lt;br&gt;{&#123;email&#125;}'</span>
})
<span class="comment">// `user` 对象会传递给子级</span>
<span class="comment">// 作为 $data</span>
<span class="keyword">var</span> parent = <span class="keyword">new</span> Vue({
  el: <span class="string">'#demo-1'</span>,
  data: {
    user: {
      name: <span class="string">'Foo Bar'</span>,
      email: <span class="string">'foo@bar.com'</span>
    }
  }
})
</pre></td></tr></table></figure>


<p><strong>结果：</strong></p>
<p><div id="demo-1" class="demo"><p v-component="user-profile" v-with="user"></p></div></p>
<script>
  Vue.component('user-profile', {
    template: '{&#123;name&#125;}<br>{&#123;email&#125;}'
  })
  var parent = new Vue({
    el: '#demo-1',
    data: {
      user: {
        name: 'Foo Bar',
        email: 'foo@bar.com'
      }
    }
  })
</script>

<h4 id="向下传递单个属性">向下传递单个属性</h4>
<p><code>v-with</code> 也能以 <code>v-with=&quot;childProp: parentProp&quot;</code> 的形式传入一个参数来使用。也就是把 <code>parent[parentProp]</code> 向下传递给子级，作为子级的属性 <code>child[childProp]</code>。从 0.11.5 版本开始，这将会在两者之间建立一个双向的数据绑定（0.11 的更早版本此绑定是单向的）。</p>
<p><strong>示例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"demo-2"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">input</span> <span class="attribute">v-model</span>=<span class="value">"parentMsg"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span> <span class="attribute">v-component</span>=<span class="value">"child"</span> <span class="attribute">v-with</span>=<span class="value">"childMsg : parentMsg"</span>&gt;</span>
    <span class="comment">&lt;!-- 实际上表示 "把 `parentMsg` 绑定到我的 `childMsg` 属性上" --&gt;</span>
  <span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>




<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">new</span> Vue({
  el: <span class="string">'#demo-2'</span>,
  data: {
    parentMsg: <span class="string">'Inherited message'</span>
  },
  components: {
    child: {
      template: <span class="string">'&lt;span&gt;{&#123;childMsg&#125;}&lt;/span&gt;'</span>
    }
  }
})
</pre></td></tr></table></figure>


<p><strong>结果</strong></p>
<p><div id="demo-2" class="demo"><input v-model="parentMsg"><p v-component="child" v-with="childMsg:parentMsg"></p></div></p>
<script>
new Vue({
  el: '#demo-2',
  data: {
    parentMsg: 'Inherited message'
  },
  components: {
    child: {
      template: '<span v-text="childMsg"></span>'
    }
  }
})
</script>

<h4 id="使用_paramAttributes_参数标识">使用 <code>paramAttributes</code> 参数标识</h4>
<p>同样可以通过 <a href="../api/options.html#paramAttributes"><code>paramAttributes</code></a> 选项（会被编译成 <code>v-with</code> ）来暴露一个看起来更像自定义元素的接口。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"demo-3"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">input</span> <span class="attribute">v-model</span>=<span class="value">"parentMsg"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">child-component</span> <span class="attribute">child-msg</span>=<span class="value">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>




<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">new</span> Vue({
  el: <span class="string">'#demo-3'</span>,
  data: {
    parentMsg: <span class="string">'Inherited message'</span>
  },
  components: {
    <span class="string">'child-component'</span>: {
      paramAttributes: [<span class="string">'child-msg'</span>],
      <span class="comment">// 连字符分隔的属性会被转成驼峰形式，</span>
      <span class="comment">// 所以“child-msg”成了“this.childMsg”</span>
      template: <span class="string">'&lt;span&gt;{&#123;childMsg&#125;}&lt;/span&gt;'</span>
    }
  }
})
</pre></td></tr></table></figure>


<h3 id="作用域继承">作用域继承</h3>
<p>如果有需要，你也可以使用 <code>inherit: true</code> 选项来让子组件通过原型链继承父级的全部属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">var</span> parent = <span class="keyword">new</span> Vue({
  data: {
    a: <span class="number">1</span>
  }
})
<span class="comment">// $addChild() 是一个实例方法，</span>
<span class="comment">// 它允许你用代码创建子实例。</span>
<span class="keyword">var</span> child = parent.$addChild({
  inherit: <span class="literal">true</span>,
  data: {
    b: <span class="number">2</span>
  }
})
console.log(child.a) <span class="comment">// -&gt; 1</span>
console.log(child.b) <span class="comment">// -&gt; 2</span>
parent.a = <span class="number">3</span>
console.log(child.a) <span class="comment">// -&gt; 3</span>
</pre></td></tr></table></figure>


<p>这里有一点需要注意：由于 Vue 示例上的数据属性都是 getter/setter，设置 <code>child.a = 2</code> 会直接改变 <code>parent.a</code> 的值，而非在子级创建一个新属性遮蔽父级中的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>child.a = <span class="number">4</span>
console.log(parent.a) <span class="comment">// -&gt; 4</span>
console.log(child.hasOwnProperty(<span class="string">'a'</span>)) <span class="comment">// -&gt; false</span>
</pre></td></tr></table></figure>


<h3 id="作用域注意事项">作用域注意事项</h3>
<p>当组件被用在父模板中时，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 父模板 --&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">v-component</span> <span class="attribute">v-show</span>=<span class="value">"active"</span> <span class="attribute">v-on</span>=<span class="value">"click:onClick"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>


<p>这里的命令（ <code>v-show</code> 和 <code>v-on</code> ）会在父作用域编译，所以 <code>active</code> 和 <code>onClick</code> 的取值取决于父级。任何子模版中的命令和插值都会在子作用域中编译。这样使得上下级组件间更好地分离。</p>
<p>这条规则同样适用于 <a href="#内容插入">内容插入</a>，这一点会在下文中详述。</p>
<h2 id="组件生命周期">组件生命周期</h2>
<p>每一个组件，或者说 Vue 的实例，都有着自己的生命周期：它会被创建、编译、附加、分离，最终销毁。在这每一个关键点，实例都会触发相应的事件，而在创建实例或者定义组件时，我们可以传入生命周期钩子函数来响应这些事件。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> MyComponent = Vue.extend({
  created: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    console.log(<span class="string">'An instance of MyComponent has been created!'</span>)
  }
})
</pre></td></tr></table></figure>


<p>查阅 API 文档中可用的 <a href="../api/options.html#Lifecycle">生命周期钩子函数完整列表</a>。</p>
<h2 id="动态组件">动态组件</h2>
<p>你可以通过在 <code>v-component</code> 命令中使用 Mustache 标签的方式在组件间动态切换，还能与路由一起使用实现“页面切换”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">new</span> Vue({
  el: <span class="string">'body'</span>,
  data: {
    currentView: <span class="string">'home'</span>
  },
  components: {
    home: { <span class="comment">/* ... */</span> },
    posts: { <span class="comment">/* ... */</span> },
    archive: { <span class="comment">/* ... */</span> }
  }
})
</pre></td></tr></table></figure>




<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">v-component</span>=<span class="value">"{&#123;currentView&#125;}"</span>&gt;</span>
  <span class="comment">&lt;!-- 内容随 vm.currentview 一同改变！ --&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>


<p>如果希望被切换出去的组件保持存活，从而保留它的当前状态或者避免反复重新渲染，你可以加上 <code>keep-alive</code> 命令参数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">v-component</span>=<span class="value">"{&#123;currentView&#125;}"</span> <span class="attribute">keep-alive</span>&gt;</span>
  <span class="comment">&lt;!-- 不活跃的的组件会被缓存！ --&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>


<h3 id="过渡控制">过渡控制</h3>
<p>有两个额外的属性能够支持对动态组件间的切换方式进行高级控制。</p>
<h4 id="wait-for_等待事件"><code>wait-for</code> 等待事件</h4>
<p>等待即将进入的组件触发该事件后再用新组件替换当前组件。这就允许你等待数据异步加载完成后再触发过渡，避免切换过程中出现空白闪烁。</p>
<p><strong>示例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">v-component</span>=<span class="value">"&#123;{view}&#125;"</span> <span class="attribute">wait-for</span>=<span class="value">"data-loaded"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>




<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="comment">// 组件定义</span>
{
  <span class="comment">// 获取数据并在编译完成钩子函数中异步触发事件。</span>
  <span class="comment">// 这里jQuery只是用作演示。</span>
  compiled: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>
    $.ajax({
      <span class="comment">// ...</span>
      success: <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
        self.$data = data
        self.$emit(<span class="string">'data-loaded'</span>)
      }
    })
  }
}
</pre></td></tr></table></figure>


<h4 id="transition-mode_过渡模式"><code>transition-mode</code> 过渡模式</h4>
<p>默认情况下，进入组件和退出组件的过渡是同时进行的。这个参数允许设置成另外两种模式：</p>
<ul>
<li><code>in-out</code>：先进后出；先执行新组件过渡，当前组件在新组件过渡结束后执行过渡并退出。</li>
<li><code>out-in</code>：先出后进；当前组件首先执行过渡并退出，新组件在当前组件过渡结束后执行过渡并进入。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 先淡出，之后淡入 --&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">v-component</span>=<span class="value">"&#123;{view}&#125;"</span>
  <span class="attribute">v-transition</span>=<span class="value">"fade"</span>
  <span class="attribute">transition-mode</span>=<span class="value">"out-in"</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>


<h2 id="列表与组件">列表与组件</h2>
<p>对于一个对象数组，你可以把 <code>v-component</code> 和 <code>v-repeat</code> 组合使用。这种场景下，对于数组中的每个对象，都以该对象为数据创建一个子 ViewModel，以指定组件作为构造函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">id</span>=<span class="value">"demo-4"</span>&gt;</span>
  <span class="comment">&lt;!-- 复用我们之前注册过的 user-profile 组件 --&gt;</span>
  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">v-repeat</span>=<span class="value">"users"</span> <span class="attribute">v-component</span>=<span class="value">"user-profile"</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</pre></td></tr></table></figure>




<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">var</span> parent2 = <span class="keyword">new</span> Vue({
  el: <span class="string">'#demo-4'</span>,
  data: {
    users: [
      {
        name: <span class="string">'Chuck Norris'</span>,
        email: <span class="string">'chuck@norris.com'</span>
      },
      {
        name: <span class="string">'Bruce Lee'</span>,
        email: <span class="string">'bruce@lee.com'</span>
      }
    ]
  }
})
</pre></td></tr></table></figure>


<p><strong>结果：</strong></p>
<p><ul id="demo-4" class="demo"><li v-repeat="users" v-component="user-profile"></li></ul></p>
<script>
var parent2 = new Vue({
  el: '#demo-4',
  data: {
    users: [
      {
        name: 'Chuck Norris',
        email: 'chuck@norris.com'
      },
      {
        name: 'Bruce Lee',
        email: 'bruce@lee.com'
      }
    ]
  }
})
</script>

<h2 id="子组件引用">子组件引用</h2>
<p>某些情况下需要通过 JavaScript 访问嵌套的子组件。要实现这种操作，需要使用 <code>v-ref</code> 为子组件分配一个 ID。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"parent"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">v-component</span>=<span class="value">"user-profile"</span> <span class="attribute">v-ref</span>=<span class="value">"profile"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>




<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">var</span> parent = <span class="keyword">new</span> Vue({ el: <span class="string">'#parent'</span> })
<span class="comment">// 访问子组件</span>
<span class="keyword">var</span> child = parent.$.profile
</pre></td></tr></table></figure>


<p>当 <code>v-ref</code> 与 <code>v-repeat</code> 一同使用时，会获得一个与数据数组对应的子组件数组。</p>
<h2 id="事件系统">事件系统</h2>
<p>虽然你可以直接访问一个 ViewModel 的子级与父级，但是通过内建的事件系统进行跨组件通讯更为便捷。这还能使你的代码进一步解耦，变得更易于维护。一旦建立了上下级关系，就能使用 ViewModel 的 <a href="../api/instance-methods.html#Events">事件示例方法</a> 来分发和触发事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">var</span> Child = Vue.extend({
  created: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">this</span>.$dispatch(<span class="string">'child-created'</span>, <span class="keyword">this</span>)
  }
})

<span class="keyword">var</span> parent = <span class="keyword">new</span> Vue({
  template: <span class="string">'&lt;div v-component="child"&gt;&lt;/div&gt;'</span>,
  components: {
    child: Child
  },
  created: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">this</span>.$on(<span class="string">'child-created'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(child)</span> {</span>
      console.log(<span class="string">'new child created: '</span>)
      console.log(child)
    })
  }
})
</pre></td></tr></table></figure>


<script>
var Child = Vue.extend({
  created: function () {
    this.$dispatch('child-created', this)
  }
})

var parent = new Vue({
  el: document.createElement('div'),
  template: '<div v-component="child"></div>',
  components: {
    child: Child
  },
  created: function () {
    this.$on('child-created', function (child) {
      console.log('new child created: ')
      console.log(child)
    })
  }
})
</script>

<h2 id="私有资源">私有资源</h2>
<p>有时一个组件需要使用类似命令、过滤器和子组件这样的资源，但是又希望把这些资源封装起来以便自己在别处复用。这一点可以用私有资源实例化选项来实现。私有资源只能被拥有该资源的组件的实例及其子组件访问。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="comment">// 全部5种类型的资源</span>
<span class="keyword">var</span> MyComponent = Vue.extend({
  directives: {
    <span class="comment">// “id : 定义”键值对，与处理全局方法的方式相同</span>
    <span class="string">'private-directive'</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
      <span class="comment">// ...</span>
    }
  },
  filters: {
    <span class="comment">// ...</span>
  },
  components: {
    <span class="comment">// ...</span>
  },
  partials: {
    <span class="comment">// ...</span>
  },
  effects: {
    <span class="comment">// ...</span>
  }
})
</pre></td></tr></table></figure>


<p>又或者，可以用与全局资源注册方法类似的链式 API 为现有组件构造方法添加私有资源：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>MyComponent
  .directive(<span class="string">'...'</span>, {})
  .filter(<span class="string">'...'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>})
  .component(<span class="string">'...'</span>, {})
  <span class="comment">// ...</span>
</pre></td></tr></table></figure>


<h2 id="内容插入">内容插入</h2>
<p>在创建可复用组件时，我们通常需要在宿主元素中访问和重用原始数据，而它们并非组件的一部分（类似 Angular 的“transclusion”概念）。 Vue.js 实现了一套内容插入机制，它和目前的 Web Components 规范草案兼容，使用特殊的 <code>&lt;content&gt;</code> 元素作为原始内容的插入点。</p>
<p class="tip">注意：“transcluded”内容在父组件的作用域中编译。</p>

<h3 id="单插入点">单插入点</h3>
<p>只有一个不带属性的 <code>&lt;content&gt;</code> 标签时，整个原始内容都会被插入到它在 DOM 中的位置并把它替换掉。原来在 <code>&lt;content&gt;</code> 标签内部的所有内容会被视为 <strong>后备内容</strong>。后备内容只有在宿主元素为空且没有要插入的内容时才会被显示。例如：</p>
<p><code>my-component</code> 的模板：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">h1</span>&gt;</span>This is my component!<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
<span class="tag">&lt;<span class="title">content</span>&gt;</span>This will only be displayed if no content is inserted<span class="tag">&lt;/<span class="title">content</span>&gt;</span>
</pre></td></tr></table></figure>


<p>使用该组件的父标签：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">v-component</span>=<span class="value">"my-component"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span>&gt;</span>This is some original content<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span>&gt;</span>This is some more original content<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>


<p>渲染结果如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;<span class="title">h1</span>&gt;</span>This is my component!<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span>&gt;</span>This is some original content<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span>&gt;</span>This is some more original content<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>


<h3 id="多插入点">多插入点</h3>
<p><code>&lt;content&gt;</code> 元素有一个特殊属性 <code>select</code>，需要赋值为一个 CSS 选择器。可以使用多个包含不同 <code>select</code> 属性的 <code>&lt;content&gt;</code> 插入点，它们会被原始内容中与选择器匹配的部分所替代。</p>
<p><code>multi-insertion-component</code> 的模板：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">content</span> <span class="attribute">select</span>=<span class="value">"p:nth-child(3)"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
<span class="tag">&lt;<span class="title">content</span> <span class="attribute">select</span>=<span class="value">"p:nth-child(2)"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
<span class="tag">&lt;<span class="title">content</span> <span class="attribute">select</span>=<span class="value">"p:nth-child(1)"</span>&gt;</span><span class="tag">&lt;/<span class="title">content</span>&gt;</span>
</pre></td></tr></table></figure>


<p>父标签：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">v-component</span>=<span class="value">"multi-insertion-component"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span>&gt;</span>One<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span>&gt;</span>Two<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span>&gt;</span>Three<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>


<p>渲染结果如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span>&gt;</span>Three<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span>&gt;</span>Two<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span>&gt;</span>One<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>


<p>内容插入机制能很好地控制对原始内容的操作和显示，使组件极为灵活多变易于组合。</p>
<p>下一节：<a href="../guide/transitions.html">过渡效果</a></p>

    <div class="footer">发现了问题或想要贡献？来 Github 给 Vue.js <a href="https://github.com/vuejs/vuejs.org" target="_blank">英文站点</a>或<a href="https://github.com/Jinjiang/vuejs.org/tree/lang-zh" target="_blank">中文翻译</a>来个 Fork 吧！</div>
</div>
            
        </div>

        
            <script src="/vuejs.org/js/smooth-scroll.min.js"></script>
            <script src="/vuejs.org/js/common.js"></script>
        

    </body>
</html>